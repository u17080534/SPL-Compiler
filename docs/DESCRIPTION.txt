# COMPILER ALGORITHM DESCRIPTION:

*SPL LANGUAGE ASSUMPTIONS*
1. Every instruction in a code block, except for the last instruction, must be followed by a semi-colon.
2. It is considered necessary to place a semicolon between an instruction and a new proc definition, this is because semicolons are needed if instruction is not last in code block.
	Grammar Rule: INSTR; PROC
3. A tab counts as 5 spaces (when counting the character position in the file)

00 - LEXER

	The Lexer implementation is as follows:

		(i) The input file is scanned, one character at a time.

		(ii) The DFA (doc included in LEXER direcotry) is implemented using a while-loop with nested if-statements as follows:

			Each IF considers the possible transitions of current state,
					and the current char is the most recently read character from the input stream:

				IF current Char matches a transition:
				 -> add current Char to the char stack (which is used as a string buffer for the constructed token)
				 -> change current State to transition State

				ELSE IF current state is accept state (implied there is no matching transitions):
				 -> accept token:
					-> character stack is cleared, and appended to the token string
					-> continue to follow the DFA, building the charStack
					-> left over characters are pushed to the buffer stack

				ELSE:
				 -> reject input & throw exception;

			Clearly, the longest potential token is chosen by the lexer (LONGEST MATCH) - this is why the buffer stack is needed: in the case that the lexer 'sees' a potential token that is longer than the currently accepted token, where it then does not find the rest of the potential token in the following characters - now these left over characters must be pushed to the stack, which is read through before the buffered character stream (so these characters are carried over for the next token to be read.)

		(iii) The DFA is continously used to scan tokens from the input stream, until the input stream is finished, it then returns the scanned tokens if no errors were thrown.

	CONTRIBUTIONS:
		BYRON TOMKINSON	- Planning: NFA+DFA Design & Conversions.
				- Programming: Lexer Class Implementation.
				- Documentation: DFA.pdf.

		JORDAN MANAS 	- Planning: NFA+DFA Design & Conversions.
				- Programming: SPL Class Implementation; Lexer Class Implementation; Unit-Testing Class Setup.
				- Documentation: Finite Automata.pdf; SPL Regular Expressions.txt; README.md; DESCRIPTION.txt.

		PATRIC EDWARDS	- Planning: NFA+DFA Design & Conversions.
				- Programming: Unit-Testing Class Implementation.

01 - PARSER

	The Parser & AST implementation is as follows:

		Changes to the given Grammar:
			- All ambiguous cases of expression derivation route were changed to have only a single route of derivation, when a lookahead would not have been sufficient in resolving the ambiguite. For example: the ASSIGN, BOOL and CALC rules were changed to remove ambiguity.

		The Parser is implemented as an LL(1) Parser. The expressions are evaluated using left-to-right derivation (i.e. inputs are read from left to right), and a look ahead of 1 position is used when evaluating tokens.

		Each grammar rule/expression is evaluated as its own function, with a corresponding name, within the Grammar class. 
		When each expression is evaluated, using the given tokens, a new concrete-expression-node object is constructed, which is to be returned recursively. 
		Each different expression from the grammar has its own corresponding concrete-expression-node used in the abstract-syntax-tree. 
		The abstract-syntax-tree is constructed by assigning a new expression-node its descendent nodes in a recursive manner, inside the constructor.
			If any tokens that do not comply with the grammar are encountered, the appropriate exception is thrown.

		The AST is then traversed and removes any unnecessary nodes.
		On construction of an expression, a linked symbol object is created, then added to the symbol table, also holding a reference to the expression node.

	CONTRIBUTIONS:
		BYRON TOMKINSON	- Planning: Grammar Design.

		JORDAN MANAS 	- Planning: Grammar Design.
				- Programming: AST Class Implementation; Expression Classes Implementation; Parser Class Implementation.
				- Documentation: Grammar.txt.

		PATRIC EDWARDS	- Programming: Unit-Testing Class Implementation.

02 - SCOPE CHECKING

	The scope checking algorithm is as follows:

		1. Build variable / proc declaration and usage lists and order them by scope and ID.

		2. Check for any delcarations with the same name, scope and type, if any occur throw an error.

		3. Assign aliases (Vn & Pn) for each declaration / definition 

		4. Find every usage of a variable
			(i) Scan the list of declarations (in backward direction) where the symbols are of less or equal scope and occurs chronologically before the usage
			(ii) If a matching declaration is found
				Rename current variable to declaration alias
			(iii) If not found
				Rename variable to U

		5. Find every call/usage of a procedure
			(i) Scan the list of declarations/definitions (in backward direction) where the symbols are of less or equal scope
			(ii) If definition is found
				Rename current call/usage to definition alias
			(iii) If not found
				Rename call to U

		6.  Rename all the delcaration symbols to their aliases

		CONTRIBUTIONS:	JORDAN MANAS

03 - TYPE CHECKING

	We do not allow variables of same name different type this would result in an error.

	1) From the list of all symbols build lists containing all variables of different types. In other words build a sperate list for string,proc,num and bool variables. 

	2) Find all variables of these types in the program and assign the respective variable types to them.

	3) Find all the IO checks and ensure trough an if statement they are of types bool,string or num.

	4) For the Assignment checks find all variable assignments and ensure that the assignment matches the type of the variable it is being assigned to.

	5) For calculations that could be nested we use recursion to first check the most inner calculation statement and simply throw an error if a non numerical value or variable was found

	6) For If and while loops we simply ensure trough if statements that the value within the condition is of type bool.

	7) For for loops we use if statements to ensure that all the values within is of type boolean we can assume the calc statement within the loop is correct since it was already checked in step 5.

		CONTRIBUTIONS:	PATRIC EDWARDS
