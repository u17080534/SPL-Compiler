# COMPILER ALGORITHM DESCRIPTION:

*SPL LANGUAGE ASSUMPTIONS*
1. Every instruction in a code block, except for the last instruction, must be followed by a semi-colon.
2. It is considered necessary to place a semicolon between an instruction and a new proc definition, this is because semicolons are needed if instruction is not last in code block.
	Grammar Rule: INSTR; PROC
3. A tab counts as 5 spaces (when counting the character position in the file)

00 - LEXER

	The Lexer implementation is as follows:

		(i) The input file is scanned, one character at a time.

		(ii) The DFA (doc included in LEXER direcotry) is implemented using a while-loop with nested if-statements as follows:

			Each IF considers the possible transitions of current state,
					and the current char is the most recently read character from the input stream:

				IF current Char matches a transition:
				 -> add current Char to the char stack (which is used as a string buffer for the constructed token)
				 -> change current State to transition State

				ELSE IF current state is accept state (implied there is no matching transitions):
				 -> accept token:
					-> character stack is cleared, and appended to the token string
					-> continue to follow the DFA, building the charStack
					-> left over characters are pushed to the buffer stack

				ELSE:
				 -> reject input & throw exception;

			Clearly, the longest potential token is chosen by the lexer (LONGEST MATCH) - this is why the buffer stack is needed: in the case that the lexer 'sees' a potential token that is longer than the currently accepted token, where it then does not find the rest of the potential token in the following characters - now these left over characters must be pushed to the stack, which is read through before the buffered character stream (so these characters are carried over for the next token to be read.)

		(iii) The DFA is continously used to scan tokens from the input stream, until the input stream is finished, it then returns the scanned tokens if no errors were thrown.

	CONTRIBUTIONS:
		BYRON TOMKINSON	- Planning: NFA+DFA Design & Conversions.
				- Programming: Lexer Class Implementation.
				- Documentation: DFA.pdf.

		JORDAN MANAS 	- Planning: NFA+DFA Design & Conversions.
				- Programming: SPL Class Implementation; Lexer Class Implementation; Unit-Testing Class Setup.
				- Documentation: Finite Automata.pdf; SPL Regular Expressions.txt; README.md; DESCRIPTION.txt.

		PATRIC EDWARDS	- Planning: NFA+DFA Design & Conversions.
				- Programming: Unit-Testing Class Implementation.

01 - PARSER

	The Parser & AST implementation is as follows:

		Changes to the given Grammar:
			- All ambiguous cases of expression derivation route were changed to have only a single route of derivation, when a lookahead would not have been sufficient in resolving the ambiguite. For example: the ASSIGN, BOOL and CALC rules were changed to remove ambiguity.

		The Parser is implemented as an LL(1) Parser. The expressions are evaluated using left-to-right derivation (i.e. inputs are read from left to right), and a look ahead of 1 position is used when evaluating tokens.

		Each grammar rule/expression is evaluated as its own function, with a corresponding name, within the Grammar class. 
		When each expression is evaluated, using the given tokens, a new concrete-expression-node object is constructed, which is to be returned recursively. 
		Each different expression from the grammar has its own corresponding concrete-expression-node used in the abstract-syntax-tree. 
		The abstract-syntax-tree is constructed by assigning a new expression-node its descendent nodes in a recursive manner, inside the constructor.
			If any tokens that do not comply with the grammar are encountered, the appropriate exception is thrown.

		The AST is then traversed and removes any unnecessary nodes.
		On construction of an expression, a linked symbol object is created, then added to the symbol table, also holding a reference to the expression node.

	CONTRIBUTIONS:
		BYRON TOMKINSON	- Planning: Grammar Design.

		JORDAN MANAS 	- Planning: Grammar Design.
				- Programming: AST Class Implementation; Expression Classes Implementation; Parser Class Implementation.
				- Documentation: Grammar.txt.

		PATRIC EDWARDS	- Programming: Unit-Testing Class Implementation.

02 - SCOPE CHECKING

	The scope checking algorithm is as follows:

		1. Build variable / proc declaration and usage lists and order them by scope and ID.

		2. Check for any delcarations with the same name, scope and type, if any occur throw an error.

		3. Assign aliases (Vn & Pn) for each declaration / definition 

		4. Find every usage of a variable
			(i) Scan the list of declarations (in backward direction) where the symbols are of less or equal scope and occurs chronologically before the usage
			(ii) If a matching declaration is found
				Rename current variable to declaration alias
			(iii) If not found
				Rename variable to U

		5. Find every call/usage of a procedure
			(i) Scan the list of declarations/definitions (in backward direction) where the symbols are of less or equal scope
			(ii) If definition is found
				Rename current call/usage to definition alias
			(iii) If not found
				Rename call to U

		6.  Rename all the delcaration symbols to their aliases

		CONTRIBUTIONS:	JORDAN MANAS

